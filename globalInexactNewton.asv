function [argmin, iterations, min] = globalInexactNewton(func, x0, epsilon, rho, p, beta, sigma, eta)
if(epsilon<0 || rho <= 0 || p <=2 || beta <= 0 || beta >= 1 || sigma<=0 || sigma >=2)
    disp("Error with paramaters");
    return;
end


x = x0;
k = 0;

maxIterations = 10000;


[fVal fGrad fHess] = func(x);




while norm(fGrad) > eps    
    %use conjugate gradient method to solve for d
    %if A is not symmetric positive definite then d = NaN;
    d = CGforLinEqns(fHess, -fGrad, -fGrad, eta*norm(fGrad));
    
    if ( isnan(d) || fGrad'*d > -sigma*norm(d)^p)
        
    %if eqn solvable, use Newton, otherwise use gradient
    if (1/cond(fHess) > 1e-12)
        d = -fHess\fGrad;
        if  (fGrad'*d>-rho*norm(d)^p)
            d = -fGrad;
        end
    else
        d = -fGrad;
    end
    
    l = 0; %lower case L

    t = 0;
    while(func(x+beta.^l*d)>func(x)+beta^l*sigma*fGrad'*d)
        l = l+1;
    end

    t = beta^l;
    k = k+1;
    x = x+t*d;
    
    if k == maxIterations
        disp("max iterations reached");
        break;
    end      
    
    [fVal fGrad fHess] = func(x);
end

argmin = x;
iterations = k;
minVal = func(x);

